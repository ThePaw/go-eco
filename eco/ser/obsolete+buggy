// Duplicated functions

// QAPGain returns gain of the permuted matrix according to Brusco 2000: 201, Eq. 5. (==HGain)
func QAPGain(dis Matrix64, p IntVector) float64 {
	if !dis.IsSymmetric() {
		panic("distance matrix not symmetric")
	}
	n := p.Len()
	if dis.Rows() != n {
		panic("bad permutation vector length")
	}

	c := 0.0
	for i := 1; i < n; i++ {
		for j := 0; j < i; j++ {
			d := math.Abs(float64(i - j))
			x := dis[p[i]][p[j]]
			c += d * x
		}
	}
	return c
}

// CompatibilityGain returns gain of the permuted matrix according to Kostopoulos & Goulermas (==G2Gain)
func CompatibilityGain(dis Matrix64, p IntVector) float64 {
	if !dis.IsSymmetric() {
		panic("distance matrix not symmetric")
	}
	n := p.Len()
	if dis.Rows() != n {
		panic("bad permutation vector length")
	}

	c := 0.0
	for i := 0; i < n-2; i++ {
		for j := i + 2; j < n; j++ {
			for k := i + 1; k < j; k++ {
				x := dis[p[i]][p[k]]
				y := dis[p[i]][p[j]]
				c += f(x, y)
			}
		}
	}
	for i := 0; i < n-2; i++ {
		for j := i + 2; j < n; j++ {
			for k := i + 1; k < j; k++ {
				x := dis[p[k]][p[j]]
				y := dis[p[i]][p[j]]
				c += f(x, y)
			}
		}
	}
	return c
}

// WeightedCompatibilityGain returns gain of the permuted matrix according to Kostopoulos & Goulermas (==G4Gain)
func WeightedCompatibilityGain(dis Matrix64, p IntVector) float64 {
	if !dis.IsSymmetric() {
		panic("distance matrix not symmetric")
	}
	n := p.Len()
	if dis.Rows() != n {
		panic("bad permutation vector length")
	}

	c := 0.0
	for i := 0; i < n-2; i++ {
		for j := i + 2; j < n; j++ {
			for k := i + 1; k < j; k++ {
				x := dis[p[i]][p[k]]
				y := dis[p[i]][p[j]]
				d := math.Abs(x - y)
				c += d * f(x, y)
			}
		}
	}
	for i := 0; i < n-2; i++ {
		for j := i + 2; j < n; j++ {
			for k := i + 1; k < j; k++ {
				x := dis[p[k]][p[j]]
				y := dis[p[i]][p[j]]
				d := math.Abs(x - y)
				c += d * f(x, y)
			}
		}
	}
	return c
}


// Obsolete function implementations
/*
// GARLoss returns the generalized anti-Robinson loss function for a distance matrix GAR(w) (Wu 2010: 773) .
func GARLoss(dis Matrix64, p IntVector, w int) float64 {
	if !dis.IsSymmetric() {
		panic("distance matrix not symmetric")
	}
	n := p.Len()
	if dis.Rows() != n {
		panic("bad permutation vector length")
	}

	sum := 0.0
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			dij := dis[p[i]][p[j]]
			for k := 0; k < n; k++ {
				dik := dis[p[i]][p[k]]
				if (i-w) <= j && j < k && k < i && dij < dik {
					sum++
				}
			}
		}
	}
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			dij := dis[p[i]][p[j]]
			for k := 0; k < n; k++ {
				dik := dis[p[i]][p[k]]
				if i < j && j < k && k <= (i+w) && dij > dik {
					sum++
				}
			}
		}
	}
	return sum
}
// StrengLossW returns a count of Anti-Robinson events (Streng and Schoenfelder 1978; Streng 1991; Chen 2002:21).
func StrengLossW(dis Matrix64, p IntVector, which int) float64 {
	//which indicates the weighing scheme
	// 1 ... no weighting (i)
	// 2 ... abs. deviations (s)
	// 3 ... weighted abs. deviations (w)

	if !dis.IsSymmetric() {
		panic("distance matrix not symmetric")
	}
	n := p.Len()
	if dis.Rows() != n {
		panic("bad permutation vector length")
	}

	sum := 0.0
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			d_ij := dis[p[i]][p[j]]
			for k := 0; k < n; k++ {
				d_ik := dis[p[i]][p[k]]
				if j < k && k < i {
					if d_ij < d_ik {

						switch which {
						case 1:
							sum++
						case 2:
							sum += math.Abs(d_ij - d_ik)
						case 3:
							sum += math.Abs(dis[p[i]][p[j]]-dis[p[i]][p[k]]) * math.Abs(d_ij-d_ik)
						}

					}
				}
			}
		}
	}

	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			d_ij := dis[p[i]][p[j]]
			for k := 0; k < n; k++ {
				d_ik := dis[p[i]][p[k]]
				if i < j && j < k {

					if d_ij > d_ik {

						switch which {
						case 1:
							sum++
						case 2:
							sum += math.Abs(d_ij - d_ik)
						case 3:
							sum += math.Abs(dis[p[i]][p[j]]-dis[p[i]][p[k]]) * math.Abs(d_ij-d_ik)
						}

					}
				}
			}
		}
	}
	return sum
}

// StrengLoss1 returns a count of Anti-Robinson events, no weighting (Streng and Schoenfelder 1978; Chen 2002:21).(also Wu 2010: 773) = AREventsViolationLoss()
func StrengLoss1(dis Matrix64, p IntVector) float64 {
	return StrengLossW(dis, p, 1)
}

// StrengLoss2 returns a count of Anti-Robinson events, weighted by abs. deviations (Streng and Schoenfelder 1978; Chen 2002:21). = WeightedAREventsViolationLoss()
func StrengLoss2(dis Matrix64, p IntVector) float64 {
	return StrengLossW(dis, p, 2)
}



///// BUGGY Functions



// StrengLoss3 returns a count of Anti-Robinson events, weighted by weighted abs. deviations (Streng and Schoenfelder 1978; Chen 2002:21). 
func StrengLoss3(dis Matrix64, p IntVector) float64 {
	return StrengLossW(dis, p, 3)
}
// GeneralizedARLoss returns loss of the permuted matrix according to Kostopoulos & Goulermas
func GeneralizedARLoss(dis Matrix64, p IntVector, w int) float64 {
	if !dis.IsSymmetric() {
		panic("distance matrix not symmetric")
	}
	n := p.Len()
	if dis.Rows() != n {
		panic("bad permutation vector length")
	}

	sum := 0.0
	for i := 0; i < n; i++ {
		for j := i + w; j < n; j++ {
			for k := i + 1; k < j; k++ {
				x := dis[p[i]][p[k]]
				y := dis[p[i]][p[j]]
				sum += g(x, y)
				x = dis[p[k]][p[j]]
				y = dis[p[i]][p[j]]
				sum += g(x, y)

			}
		}
	}
	return sum
}

// GeneralizedARLoss5 returns loss of the permuted matrix with window = 5 according to Kostopoulos & Goulermas
func GeneralizedARLoss5(dis Matrix64, p IntVector) float64 {
	w := 5
	return GeneralizedARLoss(dis, p, w)
}

// GeneralizedARLoss10 returns loss of the permuted matrix with window = 10 according to Kostopoulos & Goulermas
func GeneralizedARLoss10(dis Matrix64, p IntVector) float64 {
	w := 10
	return GeneralizedARLoss(dis, p, w)
}

// RelativeGARLoss returns loss of the permuted matrix according to Kostopoulos & Goulermas
func RelativeGARLoss(dis Matrix64, p IntVector, w int) float64 {
	c := GeneralizedARLoss(dis, p, w)
	n := float64(dis.Rows())
	v := float64(w)
	return c / (n*v*(v-1) - 2*v*(1-v*v)/3)
}

// RelativeGARLoss5 returns loss of the permuted matrix with window = 5 according to Kostopoulos & Goulermas
func RelativeGARLoss5(dis Matrix64, p IntVector) float64 {
	w := 5
	return RelativeGARLoss(dis, p, w)
}

// RelativeGARLoss10 returns loss of the permuted matrix with window = 10 according to Kostopoulos & Goulermas
func RelativeGARLoss10(dis Matrix64, p IntVector) float64 {
	w := 10
	return RelativeGARLoss(dis, p, w)
}

*/
/*
// GARLoss returns the generalized anti-Robinson loss function for a distance matrix GAR(w) (Wu 2010: 773) .
func GARLoss(dis Matrix64, p IntVector, w int) float64 {
	if !dis.IsSymmetric() {
		panic("distance matrix not symmetric")
	}
	n := p.Len()
	if dis.Rows() != n {
		panic("bad permutation vector length")
	}
	if w == 0 || w == 1 {
		return 0
	}
	sum := 0.0

	for i := w; i < n; i++ {
		for j := i - w; j < i; j++ {
			dij := dis[p[i]][p[j]]

			for k := j + 1; k < i; k++ {
if i-w <= j &&  j< k && k < i {
				dik := dis[p[i]][p[k]]
				if dij < dik {
					sum++
				}
			}}
		}


		for j := i + 1; j < i+w && j < n; j++ {
			dij := dis[p[i]][p[j]]

			for k := j + 1; k <= i+w && k< n; k++ {
if i< j && j<k && k <=  i + w   {
				dik := dis[p[i]][p[k]]
				if dij > dik {
					sum++
				}
			}}
		}
	}
	return sum
}
*/