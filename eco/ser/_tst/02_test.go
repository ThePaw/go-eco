package ser

import (
	"fmt"
	"testing"
)

func TestPsi2(t *testing.T) {
	n := 10
	// perfect Robinson matrix
	a := [][]int{
		{81, 64, 49, 17, 16, 10, 9, 4, 3, 0},
		{64, 81, 64, 49, 17, 16, 10, 9, 4, 3},
		{49, 64, 81, 64, 49, 17, 16, 10, 9, 4},
		{17, 49, 64, 81, 64, 49, 17, 16, 10, 9},
		{16, 17, 49, 64, 81, 64, 49, 17, 16, 10},
		{10, 16, 17, 49, 64, 81, 64, 49, 17, 16},
		{9, 10, 16, 17, 49, 64, 81, 64, 49, 17},
		{4, 9, 10, 16, 17, 49, 64, 81, 64, 49},
		{3, 4, 9, 10, 16, 17, 49, 64, 81, 64},
		{0, 3, 4, 9, 10, 16, 17, 49, 64, 81},
	}

	rowPerm := make([]int, n)
	for i := 0; i < n; i++ {
		rowPerm[i] = i
	}
	colPerm := make([]int, n)
	for i := 0; i < n; i++ {
		colPerm[i] = i
	}

	e := Psi(a, n, n, rowPerm, colPerm)
	fmt.Println("Energy: ", e)
}




func TestIsQ(t *testing.T) {
	rows := 10
	cols := 20
	a := [][]int{
		// perfect columnwise Q-matrix
		{0, 0, 0, 1357, 0, 0, 0, 38, 3, 0, 0, 0, 4, 0, 0, 0, 1, 0, 1141, 0},
		{0, 1, 0, 1141, 0, 0, 0, 322, 0, 0, 0, 0, 63, 0, 0, 0, 8, 0, 768, 3},
		{0, 8, 0, 768, 3, 0, 0, 888, 0, 0, 0, 0, 276, 1, 0, 0, 29, 0, 413, 15},
		{0, 29, 0, 413, 15, 0, 2, 817, 0, 0, 0, 0, 358, 4, 1, 0, 81, 0, 177, 49},
		{0, 81, 0, 177, 49, 0, 4, 251, 0, 0, 0, 0, 137, 12, 7, 0, 172, 0, 61, 127},
		{0, 172, 0, 61, 127, 0, 4, 25, 0, 3, 0, 0, 15, 29, 26, 0, 280, 0, 16, 257},
		{0, 280, 0, 16, 257, 0, 3, 0, 0, 14, 0, 0, 0, 64, 78, 0, 351, 0, 3, 408},
		{0, 351, 0, 3, 408, 0, 1, 0, 0, 43, 0, 0, 0, 119, 185, 0, 340, 0, 0, 510},
		{0, 340, 0, 0, 510, 0, 0, 0, 0, 97, 0, 0, 0, 194, 354, 0, 253, 0, 0, 502},
		{0, 253, 0, 0, 502, 1, 0, 0, 0, 163, 1, 0, 0, 275, 547, 0, 145, 0, 0, 389},
		{0, 145, 0, 0, 389, 6, 0, 0, 0, 206, 5, 0, 0, 339, 683, 1, 64, 0, 0, 238},
		{1, 64, 0, 0, 238, 29, 0, 0, 0, 196, 14, 0, 0, 364, 690, 3, 21, 0, 0, 114},
		{3, 21, 0, 0, 114, 98, 0, 0, 0, 139, 26, 98, 0, 340, 563, 4, 5, 0, 0, 43},
		{4, 5, 0, 0, 43, 243, 0, 0, 0, 74, 33, 280, 0, 276, 372, 3, 1, 0, 0, 12},
		{3, 1, 0, 0, 12, 450, 0, 0, 0, 29, 29, 10, 0, 196, 198, 1, 0, 0, 0, 3},
	}
	q:= IsQ(a, rows, cols)
	fmt.Println("Q: ", q)
}

func TestIsR(t *testing.T) {
	rows := 10
	a := [][]int{
		// perfect Robinson matrix
		{81, 64, 49, 17, 16, 10, 9, 4, 3, 0},
		{64, 81, 64, 49, 17, 16, 10, 9, 4, 3},
		{49, 64, 81, 64, 49, 17, 16, 10, 9, 4},
		{17, 49, 64, 81, 64, 49, 17, 16, 10, 9},
		{16, 17, 49, 64, 81, 64, 49, 17, 16, 10},
		{10, 16, 17, 49, 64, 81, 64, 49, 17, 16},
		{9, 10, 16, 17, 49, 64, 81, 64, 49, 17},
		{4, 9, 10, 16, 17, 49, 64, 81, 64, 49},
		{3, 4, 9, 10, 16, 17, 49, 64, 81, 64},
		{0, 3, 4, 9, 10, 16, 17, 49, 64, 81},
	}
	q := IsR(a, rows)
	fmt.Println("R: ", q)
}

func TestRobinson(t *testing.T) {
	n := 10
	a := [][]int{
		// perfect Robinson matrix
		{81, 64, 49, 17, 16, 10, 9, 4, 3, 0},
		{64, 81, 64, 49, 17, 16, 10, 9, 4, 3},
		{49, 64, 81, 64, 49, 17, 16, 10, 9, 4},
		{17, 49, 64, 81, 64, 49, 17, 16, 10, 9},
		{16, 17, 49, 64, 81, 64, 49, 17, 16, 10},
		{10, 16, 17, 49, 64, 81, 64, 49, 17, 16},
		{9, 10, 16, 17, 49, 64, 81, 64, 49, 17},
		{4, 9, 10, 16, 17, 49, 64, 81, 64, 49},
		{3, 4, 9, 10, 16, 17, 49, 64, 81, 64},
		{0, 3, 4, 9, 10, 16, 17, 49, 64, 81},
	}
	sim := aux.NewMatrixInt64(n, n)
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			sim.Set(i, j, int64(a[i][j]))
		}
	}
	_, p := RobFAntK(sim, 2, 10, 5)

	p.Print()
}

func TestIsR_2(t *testing.T) {
	rows := 10
	a := [][]int{
		// perfect Robinson matrix
		{81, 64, 49, 17, 16, 10, 9, 4, 3, 0},
		{64, 81, 64, 49, 17, 16, 10, 9, 4, 3},
		{49, 64, 81, 64, 49, 17, 16, 10, 9, 4},
		{17, 49, 64, 81, 64, 49, 17, 16, 10, 9},
		{16, 17, 49, 64, 81, 64, 49, 17, 16, 10},
		{10, 16, 17, 49, 64, 81, 64, 49, 17, 16},
		{9, 10, 16, 17, 49, 64, 81, 64, 49, 17},
		{4, 9, 10, 16, 17, 49, 64, 81, 64, 49},
		{3, 4, 9, 10, 16, 17, 49, 64, 81, 64},
		{0, 3, 4, 9, 10, 16, 17, 49, 64, 81},
	}
	q := IsR(a, rows)
	fmt.Println("R: ", q, "should be TRUE")
	a = [][]int{
	// not-perfect Anti-Robinson matrix
	{0, 5, 4, 9, 81, 16, 15, 49, 64, 20},
	{5, 0, 3, 4, 9, 25, 90, 36, 49, 64},
	{4, 3, 0, 4, 5, 9, 16, 12, 36, 49},
	{9, 4, 4, 0, 6, 4, 9, 16, 25, 36},
	{81, 9, 5, 6, 0, 4, 4, 9, 16, 25},
	{16, 25, 9, 4, 4, 0, 5, 4, 9, 16},
	{15, 90, 16, 9, 4, 5, 0, 3, 4, 9},
	{49, 36, 12, 16, 9, 4, 3, 0, 5, 4},
	{64, 49, 36, 25, 16, 9, 4, 5, 0, 4},
	{20, 64, 49, 36, 25, 16, 9, 4, 4, 0},
	}
	q = IsR(a, rows)
	fmt.Println("R: ", q, "should be FALSE")
}
func TestPoissonSampler(t *testing.T) {
	nSamp := 10
	nSpec := 20
	a := [][]int{

		{1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000},
		{1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000},
		{1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000},
		{1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000},
		{1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000},
		{1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000},
		{1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000},
		{1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000},
		{1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000},
		{1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000},
	}
	mtx := aux.NewMatrix(nSamp, nSpec)
	for i := 0; i < nSamp; i++ {
		for j := 0; j < nSpec; j++ {
			mtx.Set(i, j, float64(a[i][j]))
		}
	}

	PoissonSampler(mtx, 1.0)
	for i := 0; i < nSamp; i++ {
		for j := 0; j < nSpec; j++ {
			y := mtx.Get(i, j)
			fmt.Printf("%f ", y)
		}
		fmt.Println()
	}
}
